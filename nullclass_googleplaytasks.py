# -*- coding: utf-8 -*-
"""Nullclass_googleplaytasks.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rwVacl-hTXNEhuvMtXsnJ3OA7IAl1KhN

Ritika Iyer
Nullclass Data Analytics Internship
Real time Google Play store data analytics - Python
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.io as pio
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import webbrowser
import os
nltk.download('vader_lexicon')

from google.colab import drive
drive.mount('/content/drive')

apps_df=pd.read_csv(r"/content/drive/MyDrive/nullclass_googleplay/Play Store Data.csv")
reviews_df=pd.read_csv(r"/content/drive/MyDrive/nullclass_googleplay/User Reviews.csv")

apps_df.head()

apps_df.info()

apps_df = apps_df.dropna(subset=['Rating'])
for column in apps_df.columns :
    apps_df[column].fillna(apps_df[column].mode()[0],inplace=True)
apps_df.drop_duplicates(inplace=True)
apps_df=apps_df=apps_df[apps_df['Rating']<=5]

apps_df.info()

#Convert the Installs columns to numeric by removing commas and +
apps_df['Installs']=apps_df['Installs'].str.replace(',','').str.replace('+','').astype(int)

#Convert Price column to numeric after removing $
apps_df['Price']=apps_df['Price'].str.replace('$','').astype(float)

def convert_size(size):
    if 'M' in size:
        return float(size.replace('M',''))
    elif 'k' in size:
        return float(size.replace('k',''))/1024
    else:
        return np.nan
apps_df['Size']=apps_df['Size'].apply(convert_size)

apps_df['Log_Installs']=np.log(apps_df['Installs'])

apps_df['Reviews']=apps_df['Reviews'].astype(int)

apps_df['Log_Reviews']=np.log(apps_df['Reviews'])
apps_df.head()

def rating_group(rating):
    if rating >= 4:
        return 'Top rated app'
    elif rating >=3:
        return 'Above average'
    elif rating >=2:
        return 'Average'
    else:
        return 'Below Average'
apps_df['Rating_Group']=apps_df['Rating'].apply(rating_group)

def rating_group2(rating):
    if rating >= 4:
        return '4-5 stars'
    elif rating >=3:
        return '3-4 stars'
    elif rating >=2:
        return '2-3 stars'
    elif rating >=1:
        return '1-2 stars'
    else:
        return '0-1 stars'
apps_df['Rating_Group2']=apps_df['Rating'].apply(rating_group2)

apps_df['Revenue']=apps_df['Price']*apps_df['Installs']

apps_df['Last Updated']=pd.to_datetime(apps_df['Last Updated'],errors='coerce')
apps_df['Year']=apps_df['Last Updated'].dt.year
apps_df.head()

apps_df['Category'].unique()

rating_group_counts = apps_df["Rating_Group2"].value_counts()

# Display the counts
print(rating_group_counts)

apps_df['Category'].value_counts().nlargest(5)

reviews_df.head()

reviews_df.dropna(subset=['Translated_Review'],inplace=True)

reviews_df.head()

sia = SentimentIntensityAnalyzer()
reviews_df['Sentiment_Score']=reviews_df['Translated_Review'].apply(lambda x: sia.polarity_scores(str(x))['compound'])
reviews_df.head()

merged_df=pd.merge(apps_df,reviews_df,on='App',how='inner')
merged_df.head()

plot_containers=""

html_files_path = "/content/drive/MyDrive/html_files/"
os.makedirs(html_files_path, exist_ok=True)

# Function to save the plot as an HTML file
def save_plot_as_html(fig, filename, insight):
    global plot_containers
    filepath = os.path.join(html_files_path, filename)
    html_content = pio.to_html(fig, full_html=False, include_plotlyjs='inline')

    plot_containers += f"""
    <div class="plot-container" id="{filename}" onclick="openPlot('{filename}')">
        <div class="plot">{html_content}</div>
        <div class="insights">{insight}</div>
    </div>
    """

    # Save the HTML file to the specified path
    fig.write_html(filepath, full_html=True, include_plotlyjs='cdn')
    print(f"Plot saved successfully at: {filepath}")

plot_width=800
plot_height=500
plot_bg_color='black'
text_color='white'
title_font={'size':12}
axis_font={'size':10}

"""task 1"""

filtered_reviews = merged_df[merged_df['Reviews'] > 1000]
top_5_categories = filtered_reviews['Category'].value_counts().nlargest(5).index
filtered_reviews = filtered_reviews[filtered_reviews['Category'].isin(top_5_categories)]

print(filtered_reviews['Rating_Group2'].value_counts())

custom_colors = ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A']

sentiment_counts = (
    filtered_reviews.groupby(['Category', 'Rating_Group2', 'Sentiment'])
    .size()
    .reset_index(name='Count')
)

rating_order = ['0-1 stars', '1-2 stars', '2-3 stars', '3-4 stars', '4-5 stars']
sentiment_counts['Rating_Group2'] = pd.Categorical(
    sentiment_counts['Rating_Group2'], categories=rating_order, ordered=True
)

fig = px.bar(
    sentiment_counts,
    x='Rating_Group2',
    y='Count',
    color='Sentiment',
    facet_col='Category',
    title="Task 1:Sentiment Distribution by Rating Group for Top 5 Categories(There are no data points 1-2,2-3 stars for this condition)",
    labels={'Rating_Group2': 'Rating Group', 'Count': 'Review Count'},
    text='Category',
    category_orders={'Rating_Group2': rating_order},
    color_discrete_sequence=custom_colors,
    width=800,
    height=500
)
fig.update_layout(
    plot_bgcolor=plot_bg_color,
    paper_bgcolor=plot_bg_color,
    font_color=text_color,
    xaxis_title_font=axis_font,
    yaxis_title_font=axis_font,
    legend_title_font=axis_font,
    title_font={'size':12},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
fig.update_xaxes(title=None, showline=False, showgrid=False, ticks="")
fig.for_each_annotation(lambda a: a.update(
    text=a['text'].split("=")[-1],  # Get the category name from the annotation text
    font=dict(size=10)
))
fig.update_layout(barmode='stack')
fig.show()
save_plot_as_html(fig,"task1.html","The graph reveals that the Game category dominates in terms of review volume across all rating groups.")

"""Task 2"""

import plotly.graph_objects as go

# Filter data
january_apps = apps_df[(apps_df['Last Updated'].dt.month == 1) &
                       (apps_df['Size'] >= 10) &
                       (apps_df['Rating'] >= 4.0)]

# top categories by installs
top_categories = january_apps.groupby('Category')['Installs'].sum().nlargest(10).index
filtered_january_apps = january_apps[january_apps['Category'].isin(top_categories)]

# average ratings and total reviews
avg_ratings = filtered_january_apps.groupby('Category')['Rating'].mean()
total_reviews = filtered_january_apps.groupby('Category')['Reviews'].sum()

# Scale Total Reviews to millions
grouped_data = pd.DataFrame({
    'Category': avg_ratings.index,
    'Average Rating': avg_ratings.values,
    'Total Reviews (M)': total_reviews.values / 1e6  # Scale to millions
})

fig_grouped = go.Figure()

fig_grouped.add_trace(go.Bar(
    x=grouped_data['Category'],
    y=grouped_data['Total Reviews (M)'],
    name='Total Reviews (in Millions)',
    marker_color=custom_colors[0]
))

fig_grouped.add_trace(go.Bar(
    x=grouped_data['Category'],
    y=grouped_data['Average Rating'],
    name='Average Rating',
    marker_color=custom_colors[1]
))

fig_grouped.update_layout(
    title="Task 2:Average Rating and Total Reviews for Top 10 Categories (January Updates)",
    xaxis=dict(title="App Category"),
    yaxis=dict(
        title="Metrics (Total Reviews in Millions, Average Rating)",
        titlefont=dict(color="white"),
        tickfont=dict(color="white")
    ),
    barmode='group',
    legend=dict(
        x=0.01, y=0.99,
        bgcolor='rgba(255, 255, 255, 0)',
        bordercolor='rgba(255, 255, 255, 0)'
    ),
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    width=800,
    height=500,
    title_font={'size':16}
)
fig_grouped.update_layout(
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)

)
fig_grouped.update_layout(
    legend=dict(
        x=1.0,
        y=0.0,
        xanchor='right',
        yanchor='bottom',
        bgcolor='rgba(50, 50, 50, 0.5)',
        bordercolor='white',
        borderwidth=1
    )
)

fig_grouped.show()
save_plot_as_html(fig_grouped,"task2.html","The graph shows that the app categories with the highest average ratings (4.5-5) also tend to have lower numbers of total reviews (in the millions),with the notable exception of the Family category which has both a high average rating and a large number of reviews.")

"""Task 3"""

games_filtered = apps_df[
        (apps_df['Category'] == 'GAME') &
        (apps_df['Rating'] > 3.5) &
        (apps_df['Installs'] > 50000)]
fig_bubble = px.scatter(
        games_filtered,
        x='Size',
        y='Rating',
        size='Installs',
        color='Category',
        title="Task 3:App Size vs. Rating for 'Games' Category (Bubble Size = Installs)",
        labels={'Size': 'App Size (MB)', 'Rating': 'Average Rating'},
        hover_name='App',
        size_max=60,
        color_discrete_sequence=custom_colors
    )
fig_bubble.update_layout(
        plot_bgcolor=plot_bg_color,
        paper_bgcolor=plot_bg_color,
        font_color=text_color,
        width=800,
        height=500,
        title_font={'size':16},
        xaxis=dict(title_font={'size':12}),
        yaxis=dict(title_font={'size':12}),
        margin=dict(l=10,r=10,t=30,b=10)
    )
fig_bubble.show()
save_plot_as_html(fig_bubble,"task3.html","Mid-sized apps (20–60 MB) dominate with high installs and consistent ratings around 4.0–4.5, showing an optimal balance of size and user satisfaction.")

#Figure 1
category_counts=apps_df['Category'].value_counts().nlargest(10)
fig1=px.bar(
    x=category_counts.index,
    y=category_counts.values,
    labels={'x':'Category','y':'Count'},
    title='Top Categories on Play Store',
    color=category_counts.index,
    color_discrete_sequence=px.colors.sequential.Plasma,
    width=800,
    height=500
)
fig1.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig1,"Category Graph 1.html","The top categories on the Play Store are dominated by tools, entertainment, and productivity apps")

#Figure 2
type_counts=apps_df['Type'].value_counts()
fig2=px.pie(
    values=type_counts.values,
    names=type_counts.index,
    title='App Type Distribution',
    color_discrete_sequence=px.colors.sequential.RdBu,
    width=800,
    height=500
)
fig2.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig2,"Type Graph 2.html","Most apps on the Playstore are free, indicating a strategy to attract users first and monetize through ads or in app purchases")

#Figure 3
fig3=px.histogram(
    apps_df,
    x='Rating',
    nbins=20,
    title='Rating Distribution',
    color_discrete_sequence=['#636EFA'],
    width=800,
    height=500
)
fig3.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig3,"Rating Graph 3.html","Ratings are skewed towards higher values, suggesting that most apps are rated favorably by users")

#Figure 4
sentiment_counts=reviews_df['Sentiment_Score'].value_counts()
fig4=px.bar(
    x=sentiment_counts.index,
    y=sentiment_counts.values,
    labels={'x':'Sentiment Score','y':'Count'},
    title='Sentiment Distribution',
    color=sentiment_counts.index,
    color_discrete_sequence=px.colors.sequential.RdPu,
    width=800,
    height=500
)
fig4.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
#fig1.update_traces(marker=dict(pattern=dict(line=dict(color='white',width=1))))
save_plot_as_html(fig4,"Sentiment Graph 4.html","Sentiments in reviews show a mix of positive and negative feedback, with a slight lean towards positive sentiments")

#Figure 5
installs_by_category=apps_df.groupby('Category')['Installs'].sum().nlargest(10)
fig5=px.bar(
    x=installs_by_category.index,
    y=installs_by_category.values,
    orientation='h',
    labels={'x':'Installs','y':'Category'},
    title='Installs by Category',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.Blues,
    width=800,
    height=500
)
fig5.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig5,"Installs Graph 5.html","The categories with the most installs are social and communication apps, reflecting their broad appeal and daily usage")

# Updates Per Year Plot
updates_per_year = apps_df['Last Updated'].dt.year.value_counts().sort_index()
fig6 = px.line(
    x=updates_per_year.index,
    y=updates_per_year.values,
    labels={'x': 'Year', 'y': 'Number of Updates'},
    title='Number of Updates Over the Years',
    color_discrete_sequence=['#AB63FA'],
    width=plot_width,
    height=plot_height
)
fig6.update_layout(
    plot_bgcolor=plot_bg_color,
    paper_bgcolor=plot_bg_color,
    font_color=text_color,
    title_font=title_font,
    xaxis=dict(title_font=axis_font),
    yaxis=dict(title_font=axis_font),
    margin=dict(l=10, r=10, t=30, b=10)
)
save_plot_as_html(fig6, "Updates Graph 6.html", "Updates have been increasing over the years, showing that developers are actively maintaining and improving their apps.")

#Figure 7
revenue_by_category=apps_df.groupby('Category')['Revenue'].sum().nlargest(10)
fig7=px.bar(
    x=installs_by_category.index,
    y=installs_by_category.values,
    labels={'x':'Category','y':'Revenue'},
    title='Revenue by Category',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.Greens,
    width=800,
    height=500
)
fig7.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig7,"Revenue Graph 7.html","Categories such as Business and Productivity lead in revenue generation, indicating their monetization potential")

#Figure 8
genre_counts=apps_df['Genres'].str.split(';',expand=True).stack().value_counts().nlargest(10)
fig8=px.bar(
    x=genre_counts.index,
    y=genre_counts.values,
    labels={'x':'Genre','y':'Count'},
    title='Top Genres',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.OrRd,
    width=800,
    height=500
)
fig8.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig8,"Genre Graph 8.html","Action and Casual genres are the most common, reflecting users' preference for engaging and easy-to-play games")

#Figure 9
fig9=px.scatter(
    apps_df,
    x='Last Updated',
    y='Rating',
    color='Type',
    title='Impact of Last Update on Rating',
    color_discrete_sequence=px.colors.qualitative.Vivid,
    width=800,
    height=500
)
fig9.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig9,"Update Graph 9.html","The Scatter Plot shows a weak correlation between the last update and ratings, suggesting that more frequent updates dont always result in better ratings.")

#Figure 10
fig10=px.box(
    apps_df,
    x='Type',
    y='Rating',
    color='Type',
    title='Rating for Paid vs Free Apps',
    color_discrete_sequence=px.colors.qualitative.Pastel,
    width=800,
    height=500
)
fig10.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
save_plot_as_html(fig10,"Paid Free Graph 10.html","Paid apps generally have higher ratings compared to free apps, suggesting that users expect higher quality from apps they pay for")

plot_containers_split=plot_containers.split('</div>')

if len(plot_containers_split) > 1:
    final_plot=plot_containers_split[-2]+'</div>'
else:
    final_plot=plot_containers

dashboard_html = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Play Store Review Analytics</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            background-color: #333;
            color: #fff;
            margin: 0;
            padding: 0;
        }}
        .header {{
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background-color: #444;
        }}
        .header img {{
            margin: 0 10px;
            height: 50px;
        }}
        .note {{
            text-align: center;
            background-color: #555;
            padding: 10px;
            font-size: 14px;
            color: #ccc;
        }}
        .container {{
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            padding: 20px;
        }}
        .plot-container {{
            border: 2px solid #555;
            margin: 10px;
            padding: 10px;
            width: {plot_width}px;
            height: {plot_height}px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
        }}
        .insights {{
            display: none;
            position: absolute;
            right: 10px;
            top: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 5px;
            color: #fff;
        }}
        .plot-container:hover .insights {{
            display: block;
        }}
        .hidden {{
            display: none !important;
        }}
    </style>
    <script>
        function checkTime() {{
            const now = new Date();
            const istOffset = 5.5 * 60 * 60 * 1000; // IST offset in milliseconds
            const istTime = new Date(now.getTime() + now.getTimezoneOffset() * 60 * 1000 + istOffset);
            const hours = istTime.getHours();

            // Get elements for Graph 2 and Graph 3
            const graph2 = document.getElementById("task2.html");
            const graph3 = document.getElementById("task3.html");

            // Show Graph 2 only between 3 PM and 5 PM IST
            if (hours >= 15 && hours < 17) {{
                graph2.classList.remove("hidden");
            }} else {{
                graph2.classList.add("hidden");
            }}

            // Show Graph 3 only between 5 PM and 7 PM IST
            if (hours >= 17 && hours < 19) {{
                graph3.classList.remove("hidden");
            }} else {{
                graph3.classList.add("hidden");
            }}
        }}

        // Run the function on page load and every minute
        window.onload = checkTime;
        setInterval(checkTime, 60000);
    </script>
</head>
<body>
    <div class="header">
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Logo_2013_Google.png/800px-Logo_2013_Google.png" alt="Google Logo">
        <h1>Google Play Store Reviews Analytics</h1>
        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Google_Play_Store_badge_EN.svg/1024px-Google_Play_Store_badge_EN.svg.png" alt="Google Play Store Logo">
    </div>
    <div class="note">
        <p><strong>Note:</strong> Graph of Task 2 is visible only between <strong>3 PM IST and 5 PM IST</strong>, while Graph of Task 3 is visible only between <strong>5 PM IST and 7 PM IST</strong>. Other graphs are visible at all times.</p>
    </div>
    <div class="container">
        <div class="plot-container hidden" id="graph2">
            <h2>Task 2</h2>
            <!-- Graph 2 content -->
        </div>
        <div class="plot-container hidden" id="graph3">
            <h2>Task 3</h2>
            <!-- Graph 3 content -->
        </div>
        <!-- Other graphs (visible all the time) -->
        {plots}
    </div>
</body>
</html>
"""

final_html=dashboard_html.format(plots=plot_containers,plot_width=plot_width,plot_height=plot_height)

dashboard_path=os.path.join(html_files_path,"web page.html")

with open(dashboard_path, "w", encoding="utf-8") as f:
    f.write(final_html)

webbrowser.open('file://'+os.path.realpath(dashboard_path))